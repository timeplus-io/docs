# 多版本流

当您使用 `versioned_kv` 的模式创建一个流时，流中的数据不再是附加的。 当您直接查询流时，仅显示相同主键的最新版本。 当您在与其他流的 JOIN 中将这个流用作 “右表” 时，Timeplus 会自动选择最接近的版本。

以下是一些例子：

## 查询单个流

在此示例中，您在 `versioned_kv` 模式中创建了一个带有以下列的流 `dim_products`：

| 列名         | 数据类型                | 描述                                           |
| ---------- | ------------------- | -------------------------------------------- |
| _tp_time | datetime64(3,'UTC') | 它是为所有在 Timeplus 中的流自动创建的，并且具有毫秒精度和UTC时区的事件时间 |
| 产品名称       | 字符串                 | 产品的唯一 ID，作为主键                                |
| 价格         | 浮点数                 | 当前价格                                         |

如果您没有添加任何数据，查询 `SELECT * FROM dim_products` 将不返回任何结果并继续等待新的结果。

现在取消此查询，再向流中添加几行。

| 产品名称          | 价格  |
| ------------- | --- |
| iPhone14      | 799 |
| iPhone14_Plus | 899 |

再次运行 `SELECT * FROM dim_products` 将获得这两行。

现在，如果您再添加一行：

| 产品名称     | 价格  |
| -------- | --- |
| iPhone14 | 800 |

然后再次查询 `SELECT * FROM dim_products` 将获得两行（不是三行，因为“iPhone14”的初始价格已被覆盖）。

| 产品名称          | 价格  |
| ------------- | --- |
| iPhone14      | 800 |
| iPhone14_Plus | 899 |

正如您想象的，您可以继续添加新的行。 如果主键是新的，那么您将在查询结果中获得一个新的行。 如果主键已经存在，则前一行将被新添加行中的值覆盖。

:::info

事实上，您可以指定一个表达式作为主键。 例如，您可以使用 `first_name|' '||last_name` 来合并全名作为主键，而不是使用单列。

:::

## 在 INNER JOIN 中使用多版本流

在上述示例中，您总是获得具有相同主键的事件的最新版本。 其运行方式与 [变更日志流](changelog-stream) 类似。 这种流模式之所以被称为多版本流，是因为 Timeplus 将跟踪多个版本。 这主要在多版本流充当 JOIN 的 “右表” 时使用。

想象您有 `订单` 的一个附加流：

| _tp_time | 订单编号 | 产品名称 | 数量 |
| ---------- | ---- | ---- | -- |
|            |      |      |    |

现在运行流式SQL：

```sql
SELECT orders._tp_time, order_id,product_id,quantity, price*quantity AS amount
FROM orders JOIN dim_products USING(product_id)
```

然后添加两行：

| _tp_time               | 订单编号 | 产品名称          | 数量 |
| ------------------------ | ---- | ------------- | -- |
| 2023-04-20T10:00:00.000Z | 1    | iPhone14      | 1  |
| 2023-04-20T10:01:00.000Z | 2    | iPhone14_Plus | 1  |

在查询控制台中，您将逐一看到这两行：

| _tp_time               | 订单编号 | 产品名称          | 数量 | 金额  |
| ------------------------ | ---- | ------------- | -- | --- |
| 2023-04-20T10:00:00.000Z | 1    | iPhone14      | 1  | 800 |
| 2023-04-20T10:01:00.000Z | 2    | iPhone14_Plus | 1  | 899 |

然后，您可以通过在 `dim_products` 中添加新的一行来更改 iPhone14 的价格至799

| 产品名称     | 价格  |
| -------- | --- |
| iPhone14 | 799 |

也在 `订单` 中添加新的一行

| _tp_time               | 订单编号 | 产品名称     | 数量 |
| ------------------------ | ---- | -------- | -- |
| 2023-04-20T11:00:00.000Z | 3    | iPhone14 | 1  |

您将在前一个流式 SQL 中获得第三行：

| _tp_time               | 订单编号 | 产品名称          | 数量 | 金额  |
| ------------------------ | ---- | ------------- | -- | --- |
| 2023-04-20T10:00:00.000Z | 1    | iPhone14      | 1  | 800 |
| 2023-04-20T10:01:00.000Z | 2    | iPhone14_Plus | 1  | 899 |
| 2023-04-20T11:00:00.000Z | 3    | iPhone14      | 1  | 799 |

可以看出，iPhone14 的最新价格被应用到新事件的 JOIN 中。

您也可以运行一个流式 SQL `select sum(price) from dim_products`，它应显示1698，因为最新的价格是799和899。

如果您添加新的一行以将 iPhone14 设置为 800，取消之前的查询并再次运行，您将获得 1699。

## 在 ASOF JOIN 中使用多版本流

多版本流的最佳部分是在 `ASOF JOIN` 中 Timeplus 能够自动选择最接近的版本。

继续前面的场景。

```sql
SELECT orders._tp_time, order_id,product_id,quantity, price*quantity AS amount
FROM orders ASOF JOIN dim_products 
ON orders.product_id=dim_products.product_id AND orders._tp_time >= dim_products._tp_time
```

如果当前的 iPhone14 价格为 800，并且您添加了1部 iPhone14 的新订单，那么您将获得 800 的交易金额。

然后您将 iPhone14 的价格更改为 799，并添加一个 iPhone14 的新订单，您将获得799的交易金额。

但是，如果您在价格变动之前使用 _tp_time 添加订单，则交易金额将再次变为 800，因为 Timeplus 保留了多个版本的价格，并选择了与订单时间最匹配的旧版本。

:::info

如果你不熟悉 `ASOF JOIN` ，这个特殊的 JOIN 可以提供非精确匹配功能。 如果两个流具有相同的id，但时间戳不完全相同，这也可以很好的运作。

:::
